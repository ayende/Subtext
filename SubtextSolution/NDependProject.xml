<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend AppName="Subtext">
  <OutputDir KeepHistoric="True" KeepXmlFiles="True">C:\Projects\SubtextSystem\trunk\SubtextSolution</OutputDir>
  <Dirs>
    <Dir>C:\Projects\SubtextSystem\trunk\SubtextSolution\Subtext.Web\bin</Dir>
  </Dirs>
  <Assemblies>
    <Name Warn="True">Subtext.Web.Controls</Name>
    <Name Warn="True">Subtext.Web</Name>
    <Name Warn="True">Subtext.Scripting</Name>
    <Name Warn="True">Subtext.Providers.BlogEntryEditor.FCKeditor</Name>
    <Name Warn="True">Subtext.Installation</Name>
    <Name Warn="True">Subtext.Framework</Name>
    <Name Warn="True">Subtext.Extensibility</Name>
    <Name Warn="True">Subtext.BlogMl</Name>
  </Assemblies>
  <FrameworkAssemblies>
    <Name>Velocit.RegularExpressions</Name>
    <Name>SgmlReaderDll</Name>
    <Name>Microsoft.ApplicationBlocks.Data</Name>
    <Name>log4net</Name>
    <Name>Interop.SQLDMO</Name>
    <Name>ICSharpCode.SharpZipLib</Name>
    <Name>freetextbox</Name>
    <Name>FredCK.FCKeditorV2</Name>
    <Name>DotNetOpenMail</Name>
    <Name>CookComputing.XmlRpcV2</Name>
    <Name>blowery.Web.HttpCompress</Name>
    <Name>BlogML</Name>
    <Name>AngryPets.Web.Frameworks.ReverseDOS</Name>
  </FrameworkAssemblies>
  <Report>
    <Section Enabled="True">Application Metrics</Section>
    <Section Enabled="True">Assemblies Metrics</Section>
    <Section Enabled="True">VisualNDepend View</Section>
    <Section Enabled="True">Assemblies Abstracness vs. Instability</Section>
    <Section Enabled="True">Assemblies Dependencies</Section>
    <Section Enabled="True">Assemblies Dependencies Diagram</Section>
    <Section Enabled="True">Assemblies build order</Section>
    <Section Enabled="True">NDepend information and warnings</Section>
    <Section Enabled="True">CQL Queries and Constraints</Section>
    <Section Enabled="True">Types Metrics</Section>
    <Section Enabled="False">Types Dependencies</Section>
  </Report>
  <WarnFilter WarnNotUsedType="True" WarnNotUsedMember="True" WarnTypeVisibility="True" WarnPropertiesVisibility="True" WarnMethodsVisibility="True" WarnConstructorsVisibility="True" WarnFieldsVisibility="True" WarnEventsVisibility="True" /><CQLQueries>
    <CQLGroup Name="Naming constraints" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT FIELDS WHERE NameLike "^m_" AND IsStatic\r\n// A static field should not be named 'm_XXX'</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT FIELDS WHERE NameLike "^s_" AND !IsStatic\r\n// A non-static field should not be named 's_XXX'</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE IsInterface AND !NameLike "^I" AND !IsNested \r\n// The name of a non-nested interface should begin with a 'I'</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE IsExceptionClass AND !NameLike "Exception$" \r\n// The name of an exception class should end with 'Exception'</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE IsAttributeClass AND !NameLike "Attribute$" \r\n// The name of an attribute class should end with 'Attribute'</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE \r\n   !NameLike "^[A-Z]" AND // The name of a type should begin with an Upper letter.\r\n   !NameLike "__StaticArrayInit" AND  // Except __StaticArrayInit generated type\r\n      !NameLike "struct0x" AND           // Except struct0x generated type \r\n    !NameLike "&lt;"                      // Except C# compiler generated type</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n   !NameLike "^[A-Z]" AND \r\n   !(IsClassConstructor OR IsConstructor OR \r\n     IsPropertyGetter  OR IsPropertySetter OR\r\n     IsIndexerGetter OR IsIndexerSetter OR\r\n     IsEventAdder OR IsEventRemover OR\r\n     IsOperator)\r\n// The name of a regular method should begin with an Upper letter.</CQLQuery>
    </CQLGroup>
    <CQLGroup Name="Code Quality constraints" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT METHODS WHERE NbILInstructions &gt; 200 ORDER BY NbILInstructions DESC\r\n// METHODS WHERE NbILInstructions &gt; 200 are extremely complex and \r\n// should be split in smaller methods \r\n// (except if they are automatically generated by a tool).</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT METHODS WHERE ILCyclomaticComplexity &gt; 40 ORDER BY ILCyclomaticComplexity DESC\r\n// METHODS WHERE ILCyclomaticComplexity &gt; 20 are hard to understand and maintain.\r\n// METHODS WHERE ILCyclomaticComplexity &gt; 40 are extremely complex and should be split \r\n// in smaller methods (except if they are automatically generated by a tool).</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT METHODS WHERE NbParameters &gt; 5 ORDER BY NbParameters DESC\r\n// METHODS WHERE NbParameters &gt; 5 might be painful to call and might degrade performance. \r\n// You should prefer using additional properties/fields to the declaring type to handle \r\n// numerous states. Another alternative is to provide a class or structure dedicated to \r\n// handle arguments passing (for example see the class System.Diagnostics.ProcessStartInfo \r\n// and the method System.Diagnostics.Process.Start(ProcessStartInfo))</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT METHODS WHERE NbVariables &gt; 15 ORDER BY NbVariables DESC\r\n// METHODS WHERE NbVariables &gt; 8 are hard to understand and maintain.\r\n// METHODS WHERE NbVariables &gt; 15 are extremely complex and should be split in \r\n// smaller methods (except if they are automatically generated by a tool).</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE NbMethods &gt; 20 ORDER BY LCOM DESC\r\n// TYPES WHERE NbMethods &gt; 20 might be hard to understand and maintain \r\n// but there might be cases where it is relevant to have a high value for NbMethods. \r\n// For example, the System.Windows.Forms.DataGridView standard class has more than 1000 methods.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE NbFields &gt; 20 AND !IsEnumeration \r\n// TYPES WHERE NbFields &gt; 20 AND !IsEnumeration might be hard to understand and maintain \r\n// but there might be cases where it is relevant to have a high value for NbFields. \r\n// For example, the System.Windows.Forms.Control standard class has more than 200 fields. \r\n// The value of the metric SizeOfInst might be a better indicator of complex type.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT METHODS WHERE \r\n     (  NbILInstructions &gt; 200 OR \r\n        ILCyclomaticComplexity &gt; 50 OR \r\n        NbParameters &gt; 5 OR \r\n        NbVariables &gt; 8) \r\n     AND \r\n// Here is a way to avoid to take account of generated methods.\r\n// Another way would be to use the SELECT METHODS FROM or SELECT METHODS OUT OF facilities.\r\n     !( NameLike "InitializeComponent" OR NameLike "Generated") </CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE SizeOfInst &gt; 64 ORDER BY SizeOfInst DESC\r\n// TYPES WHERE SizeOfInst &gt; 64 might degrade performance (depending on the number of \r\n// instances created at runtime) and might be hard to maintain. \r\n// However it is not a rule since sometime there is no alternative \r\n// (the size of instances of the System.Net.NetworkInformation.SystemIcmpV6Statistics \r\n// standard class is 2064 bytes).</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10 ORDER BY LCOM DESC\r\n// TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10 might be problematic. \r\n// However, it is very hard to avoid such non-cohesive types. The LCOMHS metric\r\n// is often considered as more efficient to detect non-cohesive types.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE LCOMHS &gt; 1.0 AND NbFields &gt; 10 AND NbMethods &gt;10 ORDER BY LCOMHS DESC\r\n// TYPES WHERE LCOMHS &gt; 1.0 AND NbFields &gt; 10 AND NbMethods &gt;10 should be avoided. \r\n// Note that this constraint is stronger (and thus easier to satisfy) than the constraint \r\n// TYPES WHERE LCOM &gt; 0.8 AND NbFields &gt; 10 AND NbMethods &gt;10. </CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">SELECT TYPES WHERE DepthOfInheritance &gt; 6 ORDER BY DepthOfInheritance DESC\r\n// TYPES WHERE DepthOfInheritance &gt; 6 might be hard to maintain. However it is not \r\n// a rule since sometime your classes might inherit from tier classes which have a \r\n// high value for depth of inheritance. For example, the average depth of inheritance \r\n// for framework classes which derive from System.Windows.Forms.Control is 5.3.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE (SizeOfInst &gt; 200 ) ORDER BY SizeOfInst DESC\r\n// Type with big instances can be problematic \r\n// (Obviously the SizeOfInst metric does not do a deep traverse.\r\n//  Any instance reference field will count for 4 bytes.\r\n//  It is also unable to cop with generic types properly)</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Percentage &gt; 5 IN SELECT METHODS WHERE IsUsingBoxing OR IsUsingUnboxing \r\n// With generics, boxing and unboxing should be very rare.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Percentage &gt; 5 IN SELECT TYPES WHERE IsUsingBoxing OR IsUsingUnboxing \r\n// With generics, boxing and unboxing should be very rare.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Percentage &gt; 15 IN SELECT ASSEMBLIES WHERE NormDistFromMainSeq &gt; 0.7 ORDER BY NormDistFromMainSeq DESC</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT ASSEMBLIES WHERE RelationalCohesion &lt; 1.5 OR RelationalCohesion &gt; 4.0\r\n// As classes inside an assembly should be strongly related, \r\n// the cohesion should be high. On the other hand, a value which is too high may \r\n// indicate over-coupling. A good range for RelationalCohesion is 1.5 to 4.0.</CQLQuery>
    </CQLGroup>
    <CQLGroup Name="Design constraints" Active="True">
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE SizeOfInst ==0 AND !IsStatic AND !IsGeneric \r\n// It indicate stateless types that might eventually be turned into static classes.</CQLQuery>
      <CQLQuery Active="True" DisplayList="True" DisplayStat="True">WARN IF Count &gt; 0 IN SELECT TYPES WHERE DepthOfInheritance >= 6 ORDER BY DepthOfInheritance DESC \r\n // Branches too long in the derivation should be avoided.</CQLQuery>
    </CQLGroup>
  </CQLQueries></NDepend>